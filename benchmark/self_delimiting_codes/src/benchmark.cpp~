#include <iostream>
#include <vector>
#include <list>
#include <sdsl/vectors.hpp>
#include <sdsl/coder.hpp>

//TODO: Kommentieren wie das Ding zu compilen ist,
//macros (siehe makefile)
// - VTYPES
// - VNAMES
//assert that needed macros are defined
#ifndef VTYPES
#error "Macro VTYPES with comma - separated list of vector types has to be \
	defined for compiling benchmark"
#endif

#ifndef VNAMES
#error "Macro VNAMES with an array of characters has to be \
	defined for compiling benchmark"
#endif

using namespace std;
using namespace sdsl;
using namespace std::chrono;
using timer = std::chrono::high_resolution_clock;

const char *(vectornames[]) = VNAMES;
struct ivtestresult { //testcase for one defined int vector
	const char *vectorname;
	double enc_KBperSec; //encoding rate: kilobytes per second
	double dec_KBperSec; //decoding rate: kilobytes per second
	double comp_percent; //compression rate: needed space in percentage compared
			//to original integer vector
};

//benchmark method declaration
template<class... Vectors> //used vectors for benchmark
list<ivbenchmark> runBenchmark(); //TODO: Rückgabetyp überarbeiten

int main(int argc, char **argv)
{
	//TODO: argc und argv beachten
	//lists with vector to test
	const vector<iv_variants> testdata = {
		iv_variants("DBLPXML", "_1"),
		/*iv_variants("DNA", "_1"), TODO
		iv_variants("E_COLI", "_1"),
		iv_variants("EINSTEIN-de", "_1"),
		iv_variants("EINSTEIN-en", "_1"),
		iv_variants("ENGLISH", "_1"),
		//iv_variants("ENWIKIBIGINT", "_0"), //TODO: kein rs
		iv_variants("ENWIKISMLINT", "_0"),
		iv_variants("INFLUENZA", "_1"),
		iv_variants("PARA", "_1"),
		iv_variants("PROTEINS", "_1"),
		iv_variants("SOURCES", "_1"), */
		iv_variants("WORLDLEADER", "_1") };
	//set up result data structures
	list<iv_testresult> results;
	vector<string> codenames;
	//run tests with multiple self-delimiting codes
	RUN_TESTS(testdata, codenames, results,
                 coder::elias_delta,
	         coder::elias_gamma,
	         coder::fibonacci,
	         coder::comma<2>,
	         coder::comma<3>,
	         coder::comma<4>,
	         coder::comma<8>,
	         coder::comma<16>);
	//TODO: was mit dem resultat machen ;)
}

template<class Vector> //used test vector type
ivtestresult runTestCase( const char *vectorname, 
		const int_vector<> &testcase ) {
	ivtestresult result( vectorname );
	cout << "\t\tTesting Vector " << vectorname << endl;
	
	//test encoding rate by constructing Vector
	auto start = timer::now();
	Vector test( testcase );
	auto stop = timer::now();
	result.enc_KBperSec = size_in_bytes( testcase ) * 1024.0
		/ duration_cast<seconds>(stop-start).count();
	cout << "\t\t- Encoding rate: " << result.enc_KBperSec << "KB/s" << endl;

	//care for compression rate
	result.comp_percent = size_in_mega_bytes(test) 
		/ size_in_mega_bytes(testcase) * 100;
	cout << "\t\t- Compression rate: " << result.comp_percent << " %" << endl;
		

	ivtest 
	//first, test vlc vector in a separated block
	{
		cout << "\t\tTesting VLC Vector" << endl;
		//encoding time
    		auto start = timer::now();
		vlc_vector<Code, 128> vlc( v );
    		auto stop = timer::now();
		encodingtime.vlc_val = duration_cast<milliseconds>(stop-start).count()/(double)1000;
		cout << "\t\t- Encoding time: " << encodingtime.vlc_val << " seconds" << endl;

		//compression rate
		compressionrate.vlc_val = size_in_mega_bytes(vlc) / size_in_mega_bytes(v) * 100;
		cout << "\t\t- Compression Rate: " << compressionrate.vlc_val << " percent" << endl;


		//decoding time (by accessing entries right before samples of vlc vector)
		start = timer::now();
		for (size_t i = 127; i < vlc.size(); i += 128) {
			vlc[i];
		}
		stop = timer::now();
		decodingtime.vlc_val = duration_cast<milliseconds>(stop-start).count()/(double)1000;
		cout << "\t\t- Decoding time: " << decodingtime.vlc_val << " seconds" << endl;
	}
	//second, test enc vector
	{
		cout << "\t\tTesting ENC Vector" << endl;
		//encoding time
    		auto start = timer::now();
		enc_vector<Code, 128> enc( v );
    		auto stop = timer::now();
		encodingtime.enc_val = duration_cast<milliseconds>(stop-start).count()/(double)1000;
		cout << "\t\t- Encoding time: " << encodingtime.enc_val << " seconds" << endl;

		//compression rate
		compressionrate.enc_val = size_in_mega_bytes(enc) / size_in_mega_bytes(v) * 100;
		cout << "\t\t- Compression Rate: " << compressionrate.enc_val << " percent" << endl;

		//decoding time (same test as on vlc)
		start = timer::now();
		for (size_t i = 127; i < enc.size(); i += 128) {
			enc[i];
		}
		stop = timer::now();
		decodingtime.enc_val = duration_cast<milliseconds>(stop-start).count()/(double)1000;
		cout << "\t\t- Decoding time: " << decodingtime.enc_val << " seconds" << endl;
	}
	//and finally store results
	result.encodingtime.push_back(encodingtime);
	result.decodingtime.push_back(decodingtime);
	result.compressionrate.push_back(compressionrate);
	return 1; //return type is just needed for variadic templates, see runVectorTest
}

template<class... Coders>
iv_testresult runVectorTest( const string &vectorname, const string &path, 
			     const vector<string> &codenames ) {
	cout << "Testing Codes on vector " << vectorname << endl;
	//set up test result
	iv_testresult result( vectorname, codenames.size() );
	//load integer vector itself
    	int_vector<> v(10*(1<<20), 0);
    	v[0] = 1ULL<<63;
	 //TODO: den vektor mithilfe von path laden ;)
	cout << "\tVector loaded" << endl;

	//start test using variadic template coders
	size_t i = 0;
	uint32_t useless[] = { runSingleTest<Coders>( codenames[i++], v, result )... };
	
	//and that's all here
	cout << "\tTests done" << endl;
	return result;
}

// trim from start
static inline std::string &ltrim(std::string &s) {
        s.erase(s.begin(), find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace))));
        return s;
}

//overall test method declaration
template<class... Coders>
void runTests(const vector<iv_variants>& testdata,
	      const char *codename_str, 
              vector<string> &codenames,
              list<iv_testresult> &results) {
	//first, decode codename string which was returned from Macro.
	//code names are separated by a comma.
	stringstream ss(codename_str);
    	string codename;
	while (getline(ss, codename, ',')) {
		codenames.push_back(ltrim(codename));
	}

	//got information about used codes and test data, so output a little
	//description
	cout << "Testing " << testdata.size() * 4 << " Integer Vectors"
	     << " with " << codenames.size() << " self - delimiting codes" << endl;

	//set up specialized test results for some
	//average values to be computed
	iv_testresult overall("Overall", codenames.size());
	iv_testresult ips32("IPS 32", codenames.size());
	iv_testresult ips32_bwt("IPS 32 BWT", codenames.size());
	iv_testresult rs("RS", codenames.size());
	iv_testresult rs_bwt("RS BWT", codenames.size());
	
	//start tests now
	for (auto &data : testdata) {
		results.push_back( 
			runVectorTest<Coders...>( 
				data.vectorname, data.ips32, codenames ) );
		//TODO: Addition und Divison zum avg bilden der ganzen
		// "besonderen" Gruppen, sowie Visualisierung ;)
		
	}
	//also add overall result
	
	//TODO: Average bilden
	//results.push_front( overall );
	//TODO: ausgeben das die Testdaten alle eingesammelt wurden
	//return results;
}













//ENDE
